<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pac-Man 3D</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffff00">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PacMan3D">

    <!-- Force Landscape -->
    <meta name="screen-orientation" content="landscape">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" href="icon-192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 24px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #score { color: #ffff00; }
        #lives { color: #ff0000; margin-top: 10px; }
        #gameOver, #gameWin {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 48px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        #gameOver { color: #ff0000; }
        #gameWin { color: #00ff00; }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 14px;
            z-index: 100;
        }
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 24px;
            background: #ffff00;
            color: #000;
            border: none;
            cursor: pointer;
            border-radius: 10px;
        }
        #restartBtn:hover {
            background: #ffcc00;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #fff;
            cursor: pointer;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Portrait orientation warning */
        #portraitWarning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffff00;
            text-align: center;
            padding: 20px;
        }
        #portraitWarning .rotate-icon {
            font-size: 80px;
            animation: rotate-phone 1.5s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes rotate-phone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        @media screen and (orientation: portrait) {
            #portraitWarning {
                display: flex !important;
            }
        }
        @media screen and (orientation: landscape) {
            #portraitWarning {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="lives">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <div id="modeDisplay" style="margin-top: 10px; color: #aaa; font-size: 16px;">Mode: Classic (Press 1/2/3)</div>
    </div>
    <div id="instructions">
        WASD: move | Q/E: look left/right | R/F: look up/down | SPACE: jump | 1/2/3: camera mode
    </div>
    <div id="gameOver">
        GAME OVER
        <br>
        <button id="restartBtn" onclick="restartGame()">Play Again</button>
    </div>
    <div id="gameWin">
        YOU WIN!
        <div style="font-size: 24px; margin-top: 10px;">All 10 Stages Complete!</div>
        <br>
        <button id="restartBtn" onclick="restartGame()">Play Again</button>
    </div>
    <div id="stageCleared" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ff00; font-size: 48px; text-align: center; z-index: 200; display: none; text-shadow: 4px 4px 8px #000;">
        <div id="stageClearedText">Stage 1 Cleared!</div>
        <div id="extraLifeText" style="font-size: 32px; color: #ffff00; margin-top: 15px; display: none;">+1 UP!</div>
    </div>
    <div id="startScreen">
        <div style="font-size: 64px; color: #ffff00; text-shadow: 4px 4px 8px #000;">PAC-MAN 3D</div>
        <div style="font-size: 24px; margin-top: 30px; animation: blink 1s infinite;">Click or Press Any Key to Start</div>
    </div>

    <!-- Portrait orientation warning -->
    <div id="portraitWarning">
        <div class="rotate-icon">üì±</div>
        <div style="font-size: 32px; font-weight: bold;">Rotate to Landscape</div>
        <div style="font-size: 16px; margin-top: 15px; color: #aaa;">Then tap to start - screen will lock in landscape</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game constants
        const CELL_SIZE = 2;
        const PACMAN_SPEED = 0.08;
        const BASE_GHOST_SPEED = 0.035;
        const POWER_DURATION = 8000;
        const MAX_STAGE = 10;

        // Stage system
        let currentStage = 1;
        const stageColors = [
            0x4a3728, // Stage 1: Brown (cave)
            0x1a4a1a, // Stage 2: Dark green
            0x1a1a4a, // Stage 3: Dark blue
            0x4a1a4a, // Stage 4: Purple
            0x4a4a1a, // Stage 5: Olive
            0x1a4a4a, // Stage 6: Teal
            0x4a1a1a, // Stage 7: Dark red
            0x2a2a4a, // Stage 8: Slate blue
            0x3a2a1a, // Stage 9: Dark bronze
            0x1a1a1a  // Stage 10: Near black (hardest)
        ];

        function getGhostSpeed() {
            // Increase speed by 10% each stage
            return BASE_GHOST_SPEED * (1 + (currentStage - 1) * 0.1);
        }

        // Audio context for music
        let audioCtx = null;
        let audioUnlocked = false;

        // Initialize and unlock audio - MUST be called synchronously from user gesture on iOS
        function initAndUnlockAudio() {
            // Create AudioContext synchronously within user gesture
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('AudioContext created, state:', audioCtx.state);
                } catch (e) {
                    console.error('Failed to create AudioContext:', e);
                    return false;
                }
            }

            // Resume must happen synchronously in the gesture handler
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                }).catch(err => {
                    console.warn('AudioContext resume failed:', err);
                });
            }

            // Play silent oscillator to fully unlock iOS audio (synchronously)
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 0.001; // Nearly silent
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start(0);
                oscillator.stop(audioCtx.currentTime + 0.1);
                audioUnlocked = true;
                console.log('Audio unlocked with silent oscillator');
            } catch (e) {
                console.warn('Silent oscillator failed:', e);
            }

            return true;
        }

        // Legacy function for compatibility
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        }

        // Play a note with oscillator (MIDI-style chiptune)
        function playNote(frequency, startTime, duration, type = 'square', volume = 0.15) {
            const ctx = audioCtx;
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, startTime);

            gainNode.gain.setValueAtTime(volume, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        // Classic Pac-Man intro melody
        function playPacmanIntro() {
            initAudio();
            const ctx = audioCtx;
            const now = ctx.currentTime;

            // Note frequencies
            const notes = {
                B3: 246.94, C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23,
                G4: 392.00, A4: 440.00, B4: 493.88, C5: 523.25, D5: 587.33,
                E5: 659.25, F5: 698.46, G5: 783.99
            };

            // Pac-Man intro sequence (approximation of the classic tune)
            const melody = [
                // First phrase - ascending
                { note: 'B4', time: 0, duration: 0.12 },
                { note: 'C5', time: 0.12, duration: 0.12 },
                { note: 'D5', time: 0.24, duration: 0.12 },
                { note: 'E5', time: 0.36, duration: 0.18 },
                { note: 'C5', time: 0.54, duration: 0.12 },
                { note: 'D5', time: 0.66, duration: 0.12 },
                { note: 'B4', time: 0.78, duration: 0.24 },

                // Second phrase
                { note: 'B4', time: 1.1, duration: 0.12 },
                { note: 'C5', time: 1.22, duration: 0.12 },
                { note: 'D5', time: 1.34, duration: 0.12 },
                { note: 'E5', time: 1.46, duration: 0.18 },
                { note: 'F5', time: 1.64, duration: 0.12 },
                { note: 'G5', time: 1.76, duration: 0.12 },
                { note: 'E5', time: 1.88, duration: 0.24 },

                // Third phrase - descending
                { note: 'E5', time: 2.2, duration: 0.12 },
                { note: 'D5', time: 2.32, duration: 0.12 },
                { note: 'C5', time: 2.44, duration: 0.12 },
                { note: 'B4', time: 2.56, duration: 0.18 },
                { note: 'D5', time: 2.74, duration: 0.12 },
                { note: 'C5', time: 2.86, duration: 0.12 },
                { note: 'B4', time: 2.98, duration: 0.24 },

                // Final phrase
                { note: 'G4', time: 3.3, duration: 0.12 },
                { note: 'A4', time: 3.42, duration: 0.12 },
                { note: 'B4', time: 3.54, duration: 0.12 },
                { note: 'C5', time: 3.66, duration: 0.24 },
                { note: 'A4', time: 3.9, duration: 0.12 },
                { note: 'B4', time: 4.02, duration: 0.12 },
                { note: 'G4', time: 4.14, duration: 0.36 },
            ];

            // Play melody with square wave (classic chiptune sound)
            melody.forEach(({ note, time, duration }) => {
                playNote(notes[note], now + time, duration, 'square', 0.12);
            });

            // Add bass line for depth
            const bass = [
                { note: 'B3', time: 0, duration: 0.5 },
                { note: 'C4', time: 0.5, duration: 0.5 },
                { note: 'B3', time: 1.1, duration: 0.5 },
                { note: 'E4', time: 1.6, duration: 0.5 },
                { note: 'B3', time: 2.2, duration: 0.5 },
                { note: 'C4', time: 2.7, duration: 0.5 },
                { note: 'G4', time: 3.3, duration: 0.9 },
            ];

            bass.forEach(({ note, time, duration }) => {
                playNote(notes[note] / 2, now + time, duration, 'triangle', 0.1);
            });
        }

        // Waka waka sound effect for eating dots
        function playWaka() {
            if (!audioCtx || audioCtx.state === 'suspended') return;
            const ctx = audioCtx;
            const now = ctx.currentTime;

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'square';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);

            gain.gain.setValueAtTime(0.08, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

            osc.connect(gain);
            gain.connect(ctx.destination);

            osc.start(now);
            osc.stop(now + 0.08);
        }

        // Jump sound effect
        function playJumpSound() {
            if (!audioCtx || audioCtx.state === 'suspended') return;
            const ctx = audioCtx;
            const now = ctx.currentTime;

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'square';
            // Rising pitch for jump
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.15);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

            osc.connect(gain);
            gain.connect(ctx.destination);

            osc.start(now);
            osc.stop(now + 0.15);
        }

        // Game state
        let score = 0;
        let lives = 3;
        let gameRunning = false;  // Start paused until music plays
        let gameStarted = false;
        let powerMode = false;
        let powerTimer = null;
        let totalDots = 0;
        let collectedDots = 0;

        // Camera modes: 1 = Classic (top-down), 2 = Third-person, 3 = FPS
        let cameraMode = 2; // Default to 3rd person view
        const cameraModes = {
            1: { name: 'Classic', offsetY: 80, offsetZ: 20, lookY: 0, fov: 60 },  // Higher for 2x larger maze
            2: { name: '3rd Person', offsetY: 8, offsetZ: 12, lookAhead: 5, fov: 70 },
            3: { name: 'FPS', eyeHeight: 1.2, lookDistance: 10, fov: 90 }
        };

        // Camera orbit angle for 3rd person mode (controlled by right stick)
        let cameraOrbitAngle = 0;
        let cameraPitchAngle = 0.3; // Start slightly above (0 = level, positive = higher)
        const CAMERA_ROTATE_SPEED = 0.05;
        const CAMERA_PITCH_SPEED = 0.03;
        const CAMERA_PITCH_MIN = -0.1;  // Limit looking down (prevent underground view)
        const CAMERA_PITCH_MAX = 1.2;   // Limit looking up (almost top-down)

        // FPS camera angles (Resident Evil style free look)
        let fpsYawAngle = 0;      // Horizontal look direction
        let fpsPitchAngle = 0;    // Vertical look direction
        const FPS_LOOK_SPEED = 0.06;
        const FPS_PITCH_MIN = -0.6;  // Limit looking down
        const FPS_PITCH_MAX = 0.5;   // Limit looking up

        // Maze layout - EXPANDED 2x for wider corridors (1 = wall, 0 = path, 2 = dot, 3 = power pellet, 4 = ghost spawn)
        // Original 19x21 expanded to 37x41 with 2-wide paths
        // Dots placed only on even rows/cols to avoid doubling collectibles
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,3,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,3,1,1],
            [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
            [1,1,2,0,1,1,1,1,2,0,1,1,1,1,1,1,2,0,1,1,2,0,1,1,1,1,1,1,2,0,1,1,1,1,2,0,1,1],
            [1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1],
            [1,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1],
            [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
            [1,1,2,0,1,1,1,1,2,0,1,1,2,0,1,1,1,1,1,1,1,1,1,1,2,0,1,1,2,0,1,1,1,1,2,0,1,1],
            [1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1],
            [1,1,2,0,2,0,2,0,2,0,1,1,2,0,2,0,2,0,1,1,2,0,2,0,2,0,1,1,2,0,2,0,2,0,2,0,1,1],
            [1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1],
            [1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,2,0,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1],
            [0,0,0,0,0,0,1,1,2,0,1,1,0,0,0,0,0,0,4,0,0,0,0,0,0,0,1,1,2,0,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,4,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0],
            [1,1,1,1,1,1,1,1,2,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,2,0,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1],
            [0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,1,4,0,0,0,0,0,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,4,4,4,4,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,1,1,1,1,2,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1],
            [0,0,0,0,0,0,1,1,2,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,0,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0],
            [1,1,1,1,1,1,1,1,2,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,2,0,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1],
            [1,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1],
            [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
            [1,1,2,0,1,1,1,1,2,0,1,1,1,1,1,1,2,0,1,1,2,0,1,1,1,1,1,1,2,0,1,1,1,1,2,0,1,1],
            [1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1],
            [1,1,3,0,2,0,1,1,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,1,1,2,0,0,3,1,1],
            [1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1],
            [1,1,1,1,2,0,1,1,2,0,1,1,2,0,1,1,1,1,1,1,1,1,1,1,2,0,1,1,2,0,1,1,2,0,1,1,1,1],
            [1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1],
            [1,1,2,0,2,0,2,0,2,0,1,1,2,0,2,0,2,0,1,1,2,0,2,0,2,0,1,1,2,0,2,0,2,0,2,0,1,1],
            [1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1],
            [1,1,2,0,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,2,0,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1],
            [1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1],
            [1,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1],
            [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const MAZE_HEIGHT = maze.length;
        const MAZE_WIDTH = maze[0].length;

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 40, 160);  // Extended for 2x larger maze

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Initialize camera for Classic mode (top-down view)
        const startX = 18 * CELL_SIZE + CELL_SIZE / 2;  // 2x expanded maze position
        const startZ = 30 * CELL_SIZE + CELL_SIZE / 2;  // 2x expanded maze position
        let cameraTargetPos = new THREE.Vector3(MAZE_WIDTH * CELL_SIZE / 2, 80, MAZE_HEIGHT * CELL_SIZE + 20);  // Higher for 2x larger maze
        let cameraTargetLook = new THREE.Vector3(MAZE_WIDTH * CELL_SIZE / 2, 0, MAZE_HEIGHT * CELL_SIZE / 2);
        camera.position.copy(cameraTargetPos);
        camera.lookAt(cameraTargetLook);

        // Function to switch camera mode
        function setCameraMode(mode) {
            cameraMode = mode;
            camera.fov = cameraModes[mode].fov;
            camera.updateProjectionMatrix();

            // Update fog based on mode (extended for 2x larger maze)
            if (mode === 1) {
                scene.fog.near = 40;
                scene.fog.far = 160;
            } else if (mode === 2) {
                scene.fog.near = 30;
                scene.fog.far = 120;
            } else {
                scene.fog.near = 10;
                scene.fog.far = 80;
            }

            // Show/hide Pac-Man based on mode
            if (pacman) {
                pacman.visible = (mode !== 3);
            }

            // Handle mouse look for FPS mode
            if (mode !== 3 && document.pointerLockElement) {
                document.exitPointerLock();
            }
            // Update instructions for FPS mode
            const instructions = document.getElementById('instructions');
            if (instructions) {
                if (mode === 3) {
                    instructions.innerHTML = 'WASD: move | Click to enable mouse look | SPACE: jump | 1/2/3: camera mode';
                } else if (mode === 2) {
                    instructions.innerHTML = 'WASD: move | Q/E: rotate camera | R/F: tilt | SPACE: jump | 1/2/3: camera mode';
                } else {
                    instructions.innerHTML = 'WASD/Arrows: move | SPACE: jump | 1/2/3: camera mode';
                }
            }

            updateModeDisplay();
        }

        // Update mode display in UI
        function updateModeDisplay() {
            const modeDisplay = document.getElementById('modeDisplay');
            if (modeDisplay) {
                modeDisplay.textContent = `Mode: ${cameraModes[cameraMode].name} (Press 1/2/3)`;
            }
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting - Brighter cave atmosphere
        const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
        scene.add(ambientLight);

        // Main light from above (like a hole in cave ceiling)
        const directionalLight = new THREE.DirectionalLight(0xffffee, 1.0);
        directionalLight.position.set(20, 50, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Second directional light to illuminate far end
        const directionalLight2 = new THREE.DirectionalLight(0xeeeeff, 0.6);
        directionalLight2.position.set(20, 40, -20);
        scene.add(directionalLight2);

        // Add some point lights for cave glow effect
        const caveLight1 = new THREE.PointLight(0x6666ff, 0.8, 50);
        caveLight1.position.set(5, 8, 5);
        scene.add(caveLight1);

        const caveLight2 = new THREE.PointLight(0x6666ff, 0.8, 50);
        caveLight2.position.set(MAZE_WIDTH * CELL_SIZE - 5, 8, 5);
        scene.add(caveLight2);

        // Add a warm light near center (like torches)
        const torchLight = new THREE.PointLight(0xff6600, 0.6, 35);
        torchLight.position.set(MAZE_WIDTH * CELL_SIZE / 2, 5, MAZE_HEIGHT * CELL_SIZE / 2);
        scene.add(torchLight);

        // Corner torches array for animation
        const cornerTorches = [];

        // Create torch mesh with flame
        function createTorch(x, z) {
            const torchGroup = new THREE.Group();

            // Torch handle (wooden stick)
            const handleGeometry = new THREE.CylinderGeometry(0.08, 0.12, 1.5, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3728, emissive: 0x1a1008 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = 0.75;
            torchGroup.add(handle);

            // Torch head (wrapped cloth)
            const headGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.3, 8);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0x2a2a2a, emissive: 0x111111 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            torchGroup.add(head);

            // Flame (multiple layers for effect)
            const flameGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.9 });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.y = 2.0;
            torchGroup.add(flame);

            // Inner flame (brighter)
            const innerFlameGeometry = new THREE.ConeGeometry(0.1, 0.35, 8);
            const innerFlameMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
            const innerFlame = new THREE.Mesh(innerFlameGeometry, innerFlameMaterial);
            innerFlame.position.y = 1.95;
            torchGroup.add(innerFlame);

            // Point light for the torch
            const light = new THREE.PointLight(0xff8833, 1.5, 40);
            light.position.y = 2.5;
            torchGroup.add(light);

            torchGroup.position.set(x, 0, z);
            torchGroup.userData = { flame, innerFlame, light };

            return torchGroup;
        }

        // Add torches to all four corners
        const torchPositions = [
            { x: 2, z: 2 },                                    // Top-left
            { x: MAZE_WIDTH * CELL_SIZE - 2, z: 2 },           // Top-right
            { x: 2, z: MAZE_HEIGHT * CELL_SIZE - 2 },          // Bottom-left
            { x: MAZE_WIDTH * CELL_SIZE - 2, z: MAZE_HEIGHT * CELL_SIZE - 2 }  // Bottom-right
        ];

        torchPositions.forEach(pos => {
            const torch = createTorch(pos.x, pos.z);
            scene.add(torch);
            cornerTorches.push(torch);
        });

        // Create procedural rock texture
        function createRockTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Base rock color
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, 256, 256);

            // Add noise and variation for rock appearance
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 4 + 1;
                const brightness = Math.floor(Math.random() * 60) + 40;
                ctx.fillStyle = `rgb(${brightness}, ${brightness - 5}, ${brightness - 10})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add some cracks
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i < 15; i++) {
                ctx.beginPath();
                let x = Math.random() * 256;
                let y = Math.random() * 256;
                ctx.moveTo(x, y);
                for (let j = 0; j < 5; j++) {
                    x += (Math.random() - 0.5) * 40;
                    y += (Math.random() - 0.5) * 40;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Add highlights
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const brightness = Math.floor(Math.random() * 30) + 80;
                ctx.fillStyle = `rgba(${brightness + 20}, ${brightness + 15}, ${brightness}, 0.5)`;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 2 + 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }

        // Create bump map for rock
        function createRockBumpMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, 256, 256);

            // Add bumps
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 6 + 2;
                const brightness = Math.floor(Math.random() * 100) + 100;
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add darker spots (dents)
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = Math.random() * 4 + 1;
                const brightness = Math.floor(Math.random() * 50) + 30;
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }

        // Create floor texture (cave floor)
        function createFloorTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Dark cave floor base
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 512, 512);

            // Add stone texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3 + 0.5;
                const brightness = Math.floor(Math.random() * 30) + 20;
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness + 10})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add some moss/grime patches
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 30 + 10;
                ctx.fillStyle = `rgba(20, 40, 30, 0.3)`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }

        // Materials
        const rockTexture = createRockTexture();
        const rockBumpMap = createRockBumpMap();
        let wallMaterial = new THREE.MeshPhongMaterial({
            color: stageColors[0],
            map: rockTexture,
            bumpMap: rockBumpMap,
            bumpScale: 0.3,
            shininess: 5,
            specular: 0x222222
        });
        const floorTexture = createFloorTexture();
        const floorMaterial = new THREE.MeshPhongMaterial({
            map: floorTexture,
            bumpMap: rockBumpMap,
            bumpScale: 0.1,
            shininess: 2
        });
        const dotMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x444400 });
        const powerMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x888800 });
        const pacmanMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x444400 });
        const gloveMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x330000 });
        const shoeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x330000 });

        const ghostColors = [0xff0000, 0x00ffff, 0xffb8ff, 0xffb852];
        const scaredGhostMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, emissive: 0x000044 });

        // Ethereal ghost shader for flowing, transparent appearance
        const ghostVertexShader = `
            uniform float time;
            uniform float waveIntensity;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vDistFromTop;

            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;

                // Calculate distance from top (for fade effect at bottom)
                vDistFromTop = 1.0 - (position.y + 0.7) / 1.4;

                // Wave displacement for ethereal effect
                vec3 pos = position;

                // More intense waves at the bottom
                float bottomFactor = max(0.0, -position.y / 0.7);
                float waveAmount = bottomFactor * waveIntensity;

                // Multiple wave frequencies for organic feel
                pos.x += sin(time * 2.0 + position.y * 5.0) * waveAmount * 0.15;
                pos.z += cos(time * 1.5 + position.y * 4.0 + position.x * 2.0) * waveAmount * 0.15;

                // Vertical stretching wave at bottom
                if (position.y < -0.3) {
                    pos.y += sin(time * 3.0 + position.x * 4.0) * bottomFactor * 0.1;
                }

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const ghostFragmentShader = `
            uniform vec3 glowColor;
            uniform float time;
            uniform float opacity;
            uniform bool isScared;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying float vDistFromTop;

            void main() {
                // Base color with inner glow
                vec3 baseColor = isScared ? vec3(0.0, 0.0, 1.0) : glowColor;

                // Fresnel effect for edge glow
                vec3 viewDir = normalize(cameraPosition - vPosition);
                float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.0);

                // Ethereal pulsing
                float pulse = 0.8 + sin(time * 2.0) * 0.2;

                // Core glow (brighter in center)
                float coreBrightness = 1.0 - fresnel * 0.5;

                // Edge glow effect
                vec3 edgeGlow = baseColor * fresnel * 1.5;

                // Combine for ethereal look
                vec3 finalColor = baseColor * coreBrightness * pulse + edgeGlow;

                // Add subtle inner light variation
                finalColor += baseColor * sin(time * 3.0 + vPosition.y * 10.0) * 0.1;

                // Fade out at bottom for flowing effect
                float fadeAlpha = 1.0 - smoothstep(0.3, 1.0, vDistFromTop);

                // Add noise-like edge dissolution
                float noise = fract(sin(dot(vPosition.xy * 50.0 + time, vec2(12.9898, 78.233))) * 43758.5453);
                float edgeDissolution = smoothstep(0.7, 1.0, vDistFromTop) * noise;
                fadeAlpha = max(0.0, fadeAlpha - edgeDissolution * 0.5);

                // Final opacity with base transparency
                float finalAlpha = opacity * fadeAlpha * (0.7 + fresnel * 0.3);

                gl_FragColor = vec4(finalColor, finalAlpha);
            }
        `;

        // Create ethereal ghost material
        function createGhostMaterial(color) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    glowColor: { value: new THREE.Color(color) },
                    waveIntensity: { value: 1.0 },
                    opacity: { value: 0.85 },
                    isScared: { value: false }
                },
                vertexShader: ghostVertexShader,
                fragmentShader: ghostFragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
        }

        // Game objects
        let pacman;
        let ghosts = [];
        let dots = [];
        let walls = [];

        // Pacman state
        let pacmanPos = { x: 18, z: 30 };  // 2x expanded maze position
        let pacmanDir = { x: 0, z: 0 };
        let nextDir = { x: 0, z: 0 };
        let mouthOpen = 0;
        let mouthDir = 1;

        // Jump state
        let isJumping = false;
        let jumpVelocity = 0;
        let pacmanY = 0.8; // Base Y position
        const JUMP_FORCE = 0.35;
        const GRAVITY = 0.015;
        const GROUND_Y = 0.8;

        // Create floor
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(MAZE_WIDTH * CELL_SIZE + 4, MAZE_HEIGHT * CELL_SIZE + 4);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(MAZE_WIDTH * CELL_SIZE / 2, -0.5, MAZE_HEIGHT * CELL_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);
        }

        // Create starfield sky dome
        function createStarfield() {
            // Create a large dome above the scene with stars
            const skyGeometry = new THREE.SphereGeometry(200, 32, 32);

            // Create starfield texture
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 2048;
            starCanvas.height = 1024;
            const ctx = starCanvas.getContext('2d');

            // Dark night sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, starCanvas.height);
            gradient.addColorStop(0, '#000511');    // Deep space blue at top
            gradient.addColorStop(0.3, '#0a0a1a');  // Dark blue
            gradient.addColorStop(0.7, '#0f0f2a');  // Slightly lighter
            gradient.addColorStop(1, '#1a1a3a');    // Horizon tint
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, starCanvas.width, starCanvas.height);

            // Add stars - more dense at top (center of dome when looking up)
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * starCanvas.width;
                // Bias towards top half where you look up
                const y = Math.random() * Math.random() * starCanvas.height * 0.8;
                const size = Math.random() * 2 + 0.5;
                const brightness = Math.floor(Math.random() * 155) + 100;

                // Some stars are slightly colored
                const r = brightness + Math.floor(Math.random() * 30);
                const g = brightness + Math.floor(Math.random() * 20);
                const b = brightness + Math.floor(Math.random() * 50);

                ctx.fillStyle = `rgb(${Math.min(255, r)}, ${Math.min(255, g)}, ${Math.min(255, b)})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                // Add glow to brighter stars
                if (brightness > 200 && Math.random() > 0.7) {
                    ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Add a few larger bright stars
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * starCanvas.width;
                const y = Math.random() * starCanvas.height * 0.5;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
                // Cross sparkle
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(x - 6, y);
                ctx.lineTo(x + 6, y);
                ctx.moveTo(x, y - 6);
                ctx.lineTo(x, y + 6);
                ctx.stroke();
            }

            const starTexture = new THREE.CanvasTexture(starCanvas);
            const skyMaterial = new THREE.MeshBasicMaterial({
                map: starTexture,
                side: THREE.BackSide  // Render inside of sphere
            });

            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            sky.position.set(MAZE_WIDTH * CELL_SIZE / 2, 0, MAZE_HEIGHT * CELL_SIZE / 2);
            scene.add(sky);
        }

        // Create walls
        function createWalls() {
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE * 1.5, CELL_SIZE);

            for (let z = 0; z < MAZE_HEIGHT; z++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE * 0.75, z * CELL_SIZE + CELL_SIZE / 2);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
        }

        // Create dots
        function createDots() {
            for (let z = 0; z < MAZE_HEIGHT; z++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[z][x] === 2) {
                        const dotGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        dot.position.set(x * CELL_SIZE + CELL_SIZE / 2, 0.5, z * CELL_SIZE + CELL_SIZE / 2);
                        dot.userData = { gridX: x, gridZ: z, type: 'dot' };
                        scene.add(dot);
                        dots.push(dot);
                        totalDots++;
                    } else if (maze[z][x] === 3) {
                        const powerGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                        const power = new THREE.Mesh(powerGeometry, powerMaterial);
                        power.position.set(x * CELL_SIZE + CELL_SIZE / 2, 0.5, z * CELL_SIZE + CELL_SIZE / 2);
                        power.userData = { gridX: x, gridZ: z, type: 'power' };
                        scene.add(power);
                        dots.push(power);
                        totalDots++;
                    }
                }
            }
        }

        // Create Pacman with hands and feet
        function createPacman() {
            pacman = new THREE.Group();

            // Body (main sphere)
            const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const body = new THREE.Mesh(bodyGeometry, pacmanMaterial);
            body.castShadow = true;
            pacman.add(body);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const eyeWhiteGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const eyeWhiteMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });

            const leftEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            leftEyeWhite.position.set(-0.25, 0.35, 0.6);
            pacman.add(leftEyeWhite);

            const rightEyeWhite = new THREE.Mesh(eyeWhiteGeometry, eyeWhiteMaterial);
            rightEyeWhite.position.set(0.25, 0.35, 0.6);
            pacman.add(rightEyeWhite);

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.25, 0.35, 0.72);
            pacman.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.25, 0.35, 0.72);
            pacman.add(rightEye);

            // Arms (with gloves)
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.4, 16);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x333300 });

            // Left arm
            const leftArm = new THREE.Group();
            const leftArmMesh = new THREE.Mesh(armGeometry, armMaterial);
            leftArmMesh.rotation.z = Math.PI / 2;
            leftArm.add(leftArmMesh);

            // Left glove (hand)
            const gloveGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const leftGlove = new THREE.Mesh(gloveGeometry, gloveMaterial);
            leftGlove.position.set(-0.25, 0, 0);
            leftArm.add(leftGlove);

            leftArm.position.set(-0.7, 0, 0);
            pacman.add(leftArm);
            pacman.userData.leftArm = leftArm;

            // Right arm
            const rightArm = new THREE.Group();
            const rightArmMesh = new THREE.Mesh(armGeometry, armMaterial);
            rightArmMesh.rotation.z = Math.PI / 2;
            rightArm.add(rightArmMesh);

            // Right glove (hand)
            const rightGlove = new THREE.Mesh(gloveGeometry, gloveMaterial);
            rightGlove.position.set(0.25, 0, 0);
            rightArm.add(rightGlove);

            rightArm.position.set(0.7, 0, 0);
            pacman.add(rightArm);
            pacman.userData.rightArm = rightArm;

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.35, 16);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x333300 });

            // Left leg
            const leftLeg = new THREE.Group();
            const leftLegMesh = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.add(leftLegMesh);

            // Left shoe (foot)
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.12, 0.3);
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(0, -0.22, 0.05);
            leftLeg.add(leftShoe);

            leftLeg.position.set(-0.3, -0.7, 0);
            pacman.add(leftLeg);
            pacman.userData.leftLeg = leftLeg;

            // Right leg
            const rightLeg = new THREE.Group();
            const rightLegMesh = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.add(rightLegMesh);

            // Right shoe (foot)
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0, -0.22, 0.05);
            rightLeg.add(rightShoe);

            rightLeg.position.set(0.3, -0.7, 0);
            pacman.add(rightLeg);
            pacman.userData.rightLeg = rightLeg;

            // Store body reference for animations
            pacman.userData.body = body;
            pacman.userData.walkCycle = 0;

            pacman.position.set(
                pacmanPos.x * CELL_SIZE + CELL_SIZE / 2,
                0.8,
                pacmanPos.z * CELL_SIZE + CELL_SIZE / 2
            );

            scene.add(pacman);
        }

        // Create custom ethereal ghost geometry with flowing bottom
        function createEtherealGhostGeometry() {
            // Custom geometry combining dome top with flowing tendrils at bottom
            const segments = 32;
            const rings = 24;
            const radius = 0.7;

            const positions = [];
            const normals = [];
            const uvs = [];
            const indices = [];

            // Create dome top (hemisphere)
            for (let ring = 0; ring <= rings / 2; ring++) {
                const phi = (ring / (rings / 2)) * Math.PI / 2; // 0 to PI/2
                const y = Math.cos(phi) * radius;
                const ringRadius = Math.sin(phi) * radius;

                for (let seg = 0; seg <= segments; seg++) {
                    const theta = (seg / segments) * Math.PI * 2;
                    const x = Math.cos(theta) * ringRadius;
                    const z = Math.sin(theta) * ringRadius;

                    positions.push(x, y + 0.3, z);
                    normals.push(x / radius, y / radius, z / radius);
                    uvs.push(seg / segments, ring / rings);
                }
            }

            // Create flowing bottom section with wavy tendrils
            const bottomRings = rings / 2;
            const tendrilCount = 8;

            for (let ring = 0; ring <= bottomRings; ring++) {
                const t = ring / bottomRings;
                const y = -t * 0.7 + 0.3; // Extends downward
                const baseRadius = radius * (1 - t * 0.3); // Slight taper

                for (let seg = 0; seg <= segments; seg++) {
                    const theta = (seg / segments) * Math.PI * 2;

                    // Add tendril waviness
                    const tendrilPhase = Math.sin(theta * tendrilCount) * 0.5 + 0.5;
                    const tendrilExtend = tendrilPhase * t * 0.3;
                    const currentRadius = baseRadius + tendrilExtend;

                    // Add noise-like variation
                    const noise = Math.sin(theta * 7 + t * 5) * 0.05 * t;

                    const x = Math.cos(theta) * (currentRadius + noise);
                    const z = Math.sin(theta) * (currentRadius + noise);

                    positions.push(x, y, z);

                    // Normal pointing outward with some downward blend
                    const nx = Math.cos(theta);
                    const nz = Math.sin(theta);
                    const ny = -t * 0.5;
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    normals.push(nx / len, ny / len, nz / len);

                    uvs.push(seg / segments, 0.5 + ring / rings * 0.5);
                }
            }

            // Create indices for triangles
            const vertsPerRing = segments + 1;
            const totalRings = rings / 2 + bottomRings;

            for (let ring = 0; ring < totalRings; ring++) {
                for (let seg = 0; seg < segments; seg++) {
                    const curr = ring * vertsPerRing + seg;
                    const next = curr + vertsPerRing;

                    indices.push(curr, next, curr + 1);
                    indices.push(curr + 1, next, next + 1);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);

            return geometry;
        }

        // Create ghosts
        function createGhosts() {
            const ghostSpawns = [];
            for (let z = 0; z < MAZE_HEIGHT; z++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[z][x] === 4) {
                        ghostSpawns.push({ x, z });
                    }
                }
            }

            const etherealGeometry = createEtherealGhostGeometry();

            ghostSpawns.forEach((spawn, index) => {
                const ghostGroup = new THREE.Group();
                const ghostColor = ghostColors[index % ghostColors.length];

                // Main ethereal body with custom shader
                const ghostMaterial = createGhostMaterial(ghostColor);
                const body = new THREE.Mesh(etherealGeometry, ghostMaterial);
                body.position.y = 0.5;
                ghostGroup.add(body);

                // Inner glow core (smaller, more opaque)
                const coreGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: ghostColor,
                    transparent: true,
                    opacity: 0.3
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 0.6;
                ghostGroup.add(core);

                // Floating particle trails (small spheres)
                const particleGroup = new THREE.Group();
                const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: ghostColor,
                    transparent: true,
                    opacity: 0.6
                });

                for (let i = 0; i < 12; i++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                    particle.userData.angle = (i / 12) * Math.PI * 2;
                    particle.userData.yOffset = Math.random() * 0.5;
                    particle.userData.radius = 0.3 + Math.random() * 0.3;
                    particle.userData.speed = 0.5 + Math.random() * 0.5;
                    particleGroup.add(particle);
                }
                ghostGroup.add(particleGroup);

                // Eyes (ethereal glow effect)
                const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9
                });
                const pupilGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const pupilMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.95
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.2, 0.75, 0.45);
                ghostGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.2, 0.75, 0.45);
                ghostGroup.add(rightEye);

                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(-0.2, 0.75, 0.52);
                ghostGroup.add(leftPupil);

                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(0.2, 0.75, 0.52);
                ghostGroup.add(rightPupil);

                // Point light for ethereal glow
                const ghostLight = new THREE.PointLight(ghostColor, 0.5, 8);
                ghostLight.position.y = 0.5;
                ghostGroup.add(ghostLight);

                ghostGroup.position.set(
                    spawn.x * CELL_SIZE + CELL_SIZE / 2,
                    0,
                    spawn.z * CELL_SIZE + CELL_SIZE / 2
                );

                ghostGroup.userData = {
                    gridX: spawn.x,
                    gridZ: spawn.z,
                    dir: { x: 0, z: -1 },
                    originalColor: ghostColor,
                    bodyMesh: body,
                    ghostMaterial: ghostMaterial,
                    coreMesh: core,
                    particleGroup: particleGroup,
                    ghostLight: ghostLight,
                    scared: false,
                    phaseOffset: Math.random() * Math.PI * 2
                };

                scene.add(ghostGroup);
                ghosts.push(ghostGroup);
            });
        }

        // Check if position is valid (not a wall)
        function isValidPosition(x, z) {
            const gridX = Math.floor(x);
            const gridZ = Math.floor(z);

            if (gridX < 0 || gridX >= MAZE_WIDTH || gridZ < 0 || gridZ >= MAZE_HEIGHT) {
                return false;
            }

            return maze[gridZ][gridX] !== 1;
        }

        // Get valid directions from a position
        function getValidDirections(gridX, gridZ) {
            const directions = [];
            if (isValidPosition(gridX, gridZ - 1)) directions.push({ x: 0, z: -1 });
            if (isValidPosition(gridX, gridZ + 1)) directions.push({ x: 0, z: 1 });
            if (isValidPosition(gridX - 1, gridZ)) directions.push({ x: -1, z: 0 });
            if (isValidPosition(gridX + 1, gridZ)) directions.push({ x: 1, z: 0 });
            return directions;
        }

        // Update Pacman
        // Check if any movement key or gamepad stick is active
        function isMovementActive() {
            // Check keyboard
            if (keys['w'] || keys['a'] || keys['s'] || keys['d'] ||
                keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) {
                return true;
            }
            // Check gamepad
            if (gamepadIndex !== null) {
                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[gamepadIndex];
                if (gamepad) {
                    const leftStickX = gamepad.axes[0];
                    const leftStickY = gamepad.axes[1];
                    const dpad = gamepad.buttons[12]?.pressed || gamepad.buttons[13]?.pressed ||
                                 gamepad.buttons[14]?.pressed || gamepad.buttons[15]?.pressed;
                    if (dpad || Math.abs(leftStickX) > 0.3 || Math.abs(leftStickY) > 0.3) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updatePacman() {
            if (!gameRunning) return;

            // Try to change direction if requested
            const nextGridX = Math.round(pacmanPos.x + nextDir.x * 0.5);
            const nextGridZ = Math.round(pacmanPos.z + nextDir.z * 0.5);

            if (isValidPosition(nextGridX, nextGridZ)) {
                pacmanDir = { ...nextDir };
            }

            // In 3rd person mode (2), only move while key/stick is held
            // In classic (1) and FPS (3), use traditional auto-move
            const shouldMove = cameraMode !== 2 || isMovementActive();

            if (shouldMove) {
                // Move Pacman (half speed in FPS mode for playability)
                const moveSpeed = cameraMode === 3 ? PACMAN_SPEED * 0.5 : PACMAN_SPEED;
                const newX = pacmanPos.x + pacmanDir.x * moveSpeed;
                const newZ = pacmanPos.z + pacmanDir.z * moveSpeed;

                const checkX = Math.round(newX + pacmanDir.x * 0.4);
                const checkZ = Math.round(newZ + pacmanDir.z * 0.4);

                if (isValidPosition(checkX, checkZ)) {
                    pacmanPos.x = newX;
                    pacmanPos.z = newZ;
                }
            }

            // Wrap around
            if (pacmanPos.x < -0.5) pacmanPos.x = MAZE_WIDTH - 0.5;
            if (pacmanPos.x > MAZE_WIDTH - 0.5) pacmanPos.x = -0.5;

            // Jump physics
            if (isJumping) {
                pacmanY += jumpVelocity;
                jumpVelocity -= GRAVITY;

                // Land on ground
                if (pacmanY <= GROUND_Y) {
                    pacmanY = GROUND_Y;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }

            // Update mesh position
            pacman.position.x = pacmanPos.x * CELL_SIZE + CELL_SIZE / 2;
            pacman.position.y = pacmanY;
            pacman.position.z = pacmanPos.z * CELL_SIZE + CELL_SIZE / 2;

            // Rotate Pacman based on direction
            if (pacmanDir.x !== 0 || pacmanDir.z !== 0) {
                pacman.rotation.y = Math.atan2(pacmanDir.x, pacmanDir.z);
            }

            // Animate mouth (scale the body)
            mouthOpen += mouthDir * 0.15;
            if (mouthOpen > 1) { mouthOpen = 1; mouthDir = -1; }
            if (mouthOpen < 0) { mouthOpen = 0; mouthDir = 1; }

            if (pacman.userData.body) {
                pacman.userData.body.scale.x = 1 - mouthOpen * 0.2;
            }

            // Animate arms and legs when moving
            if (pacmanDir.x !== 0 || pacmanDir.z !== 0) {
                pacman.userData.walkCycle += 0.3;
                const swing = Math.sin(pacman.userData.walkCycle) * 0.5;

                // Swing arms
                if (pacman.userData.leftArm) {
                    pacman.userData.leftArm.rotation.x = swing;
                }
                if (pacman.userData.rightArm) {
                    pacman.userData.rightArm.rotation.x = -swing;
                }

                // Swing legs (opposite to arms)
                if (pacman.userData.leftLeg) {
                    pacman.userData.leftLeg.rotation.x = -swing * 0.8;
                }
                if (pacman.userData.rightLeg) {
                    pacman.userData.rightLeg.rotation.x = swing * 0.8;
                }
            }

            // Check dot collection
            checkDotCollection();
        }

        // Check dot collection
        function checkDotCollection() {
            const pacGridX = Math.round(pacmanPos.x);
            const pacGridZ = Math.round(pacmanPos.z);

            for (let i = dots.length - 1; i >= 0; i--) {
                const dot = dots[i];
                if (dot.userData.gridX === pacGridX && dot.userData.gridZ === pacGridZ) {
                    scene.remove(dot);
                    dots.splice(i, 1);
                    collectedDots++;

                    // Play waka sound
                    playWaka();

                    if (dot.userData.type === 'power') {
                        score += 50;
                        activatePowerMode();
                    } else {
                        score += 10;
                    }

                    updateUI();

                    if (collectedDots >= totalDots) {
                        winGame();
                    }
                }
            }
        }

        // Activate power mode
        function activatePowerMode() {
            powerMode = true;

            ghosts.forEach(ghost => {
                ghost.userData.scared = true;

                // Update shader to scared state
                if (ghost.userData.ghostMaterial) {
                    ghost.userData.ghostMaterial.uniforms.isScared.value = true;
                    ghost.userData.ghostMaterial.uniforms.glowColor.value.setHex(0x0000ff);
                }

                // Update core to blue
                if (ghost.userData.coreMesh) {
                    ghost.userData.coreMesh.material.color.setHex(0x0000ff);
                }

                // Update particles to blue
                if (ghost.userData.particleGroup) {
                    ghost.userData.particleGroup.children.forEach(p => {
                        p.material.color.setHex(0x0000ff);
                    });
                }

                // Update ghost light to blue
                if (ghost.userData.ghostLight) {
                    ghost.userData.ghostLight.color.setHex(0x0000ff);
                }
            });

            if (powerTimer) clearTimeout(powerTimer);
            powerTimer = setTimeout(() => {
                powerMode = false;
                ghosts.forEach(ghost => {
                    ghost.userData.scared = false;

                    // Restore shader to normal state
                    if (ghost.userData.ghostMaterial) {
                        ghost.userData.ghostMaterial.uniforms.isScared.value = false;
                        ghost.userData.ghostMaterial.uniforms.glowColor.value.setHex(ghost.userData.originalColor);
                    }

                    // Restore core color
                    if (ghost.userData.coreMesh) {
                        ghost.userData.coreMesh.material.color.setHex(ghost.userData.originalColor);
                    }

                    // Restore particles color
                    if (ghost.userData.particleGroup) {
                        ghost.userData.particleGroup.children.forEach(p => {
                            p.material.color.setHex(ghost.userData.originalColor);
                        });
                    }

                    // Restore ghost light color
                    if (ghost.userData.ghostLight) {
                        ghost.userData.ghostLight.color.setHex(ghost.userData.originalColor);
                    }
                });
            }, POWER_DURATION);
        }

        // Update ghosts
        function updateGhosts() {
            if (!gameRunning) return;

            ghosts.forEach(ghost => {
                const gridX = Math.round(ghost.userData.gridX);
                const gridZ = Math.round(ghost.userData.gridZ);

                // Check if at intersection
                const atCenter = Math.abs(ghost.userData.gridX - gridX) < 0.1 &&
                                Math.abs(ghost.userData.gridZ - gridZ) < 0.1;

                if (atCenter) {
                    const directions = getValidDirections(gridX, gridZ);

                    // Remove opposite direction (no 180 turns unless necessary)
                    const opposite = { x: -ghost.userData.dir.x, z: -ghost.userData.dir.z };
                    const filteredDirs = directions.filter(d =>
                        !(d.x === opposite.x && d.z === opposite.z)
                    );

                    const availableDirs = filteredDirs.length > 0 ? filteredDirs : directions;

                    if (availableDirs.length > 0) {
                        if (ghost.userData.scared) {
                            // Run away from Pacman
                            let bestDir = availableDirs[0];
                            let maxDist = -Infinity;

                            availableDirs.forEach(dir => {
                                const newX = gridX + dir.x;
                                const newZ = gridZ + dir.z;
                                const dist = Math.sqrt(
                                    Math.pow(newX - pacmanPos.x, 2) +
                                    Math.pow(newZ - pacmanPos.z, 2)
                                );
                                if (dist > maxDist) {
                                    maxDist = dist;
                                    bestDir = dir;
                                }
                            });
                            ghost.userData.dir = bestDir;
                        } else {
                            // Chase Pacman (with some randomness)
                            if (Math.random() < 0.7) {
                                let bestDir = availableDirs[0];
                                let minDist = Infinity;

                                availableDirs.forEach(dir => {
                                    const newX = gridX + dir.x;
                                    const newZ = gridZ + dir.z;
                                    const dist = Math.sqrt(
                                        Math.pow(newX - pacmanPos.x, 2) +
                                        Math.pow(newZ - pacmanPos.z, 2)
                                    );
                                    if (dist < minDist) {
                                        minDist = dist;
                                        bestDir = dir;
                                    }
                                });
                                ghost.userData.dir = bestDir;
                            } else {
                                ghost.userData.dir = availableDirs[Math.floor(Math.random() * availableDirs.length)];
                            }
                        }
                    }
                }

                // Move ghost (speed increases each stage)
                const ghostSpeed = getGhostSpeed();
                const speed = ghost.userData.scared ? ghostSpeed * 0.5 : ghostSpeed;
                ghost.userData.gridX += ghost.userData.dir.x * speed;
                ghost.userData.gridZ += ghost.userData.dir.z * speed;

                // Wrap around
                if (ghost.userData.gridX < -0.5) ghost.userData.gridX = MAZE_WIDTH - 0.5;
                if (ghost.userData.gridX > MAZE_WIDTH - 0.5) ghost.userData.gridX = -0.5;

                // Update position
                ghost.position.x = ghost.userData.gridX * CELL_SIZE + CELL_SIZE / 2;
                ghost.position.z = ghost.userData.gridZ * CELL_SIZE + CELL_SIZE / 2;

                // Rotate ghost to face movement direction
                ghost.rotation.y = Math.atan2(ghost.userData.dir.x, ghost.userData.dir.z);

                // Check collision with Pacman
                checkGhostCollision(ghost);
            });
        }

        // Check ghost collision
        function checkGhostCollision(ghost) {
            // Skip collision if Pac-Man is jumping high enough
            if (isJumping && pacmanY > GROUND_Y + 1.0) {
                return; // Pac-Man is in the air, safe from ghosts
            }

            const dist = Math.sqrt(
                Math.pow(ghost.userData.gridX - pacmanPos.x, 2) +
                Math.pow(ghost.userData.gridZ - pacmanPos.z, 2)
            );

            if (dist < 0.8) {
                if (ghost.userData.scared) {
                    // Eat ghost
                    score += 200;
                    updateUI();

                    // Reset ghost position
                    ghost.userData.gridX = 9;
                    ghost.userData.gridZ = 9;
                    ghost.userData.scared = false;

                    // Restore shader to normal state
                    if (ghost.userData.ghostMaterial) {
                        ghost.userData.ghostMaterial.uniforms.isScared.value = false;
                        ghost.userData.ghostMaterial.uniforms.glowColor.value.setHex(ghost.userData.originalColor);
                    }

                    // Restore core color
                    if (ghost.userData.coreMesh) {
                        ghost.userData.coreMesh.material.color.setHex(ghost.userData.originalColor);
                    }

                    // Restore particles color
                    if (ghost.userData.particleGroup) {
                        ghost.userData.particleGroup.children.forEach(p => {
                            p.material.color.setHex(ghost.userData.originalColor);
                        });
                    }

                    // Restore ghost light color
                    if (ghost.userData.ghostLight) {
                        ghost.userData.ghostLight.color.setHex(ghost.userData.originalColor);
                    }
                } else {
                    // Pacman dies
                    loseLife();
                }
            }
        }

        // Lose life
        function loseLife() {
            lives--;
            updateUI();

            if (lives <= 0) {
                gameOver();
            } else {
                // Reset positions
                pacmanPos = { x: 18, z: 30 };  // 2x expanded maze position
                pacmanDir = { x: 0, z: 0 };
                nextDir = { x: 0, z: 0 };

                ghosts.forEach((ghost, index) => {
                    // Use ghostSpawnPositions for 2x expanded maze
                    const spawnPos = ghostSpawnPositions[index % ghostSpawnPositions.length];
                    ghost.userData.gridX = spawnPos.x;
                    ghost.userData.gridZ = spawnPos.z;
                    ghost.userData.dir = { x: 0, z: -1 };
                });
            }
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Ghost spawn positions from maze (where maze[z][x] === 4)
        // Ghost spawn positions - 2x expanded maze (original positions * 2)
        const ghostSpawnPositions = [
            { x: 18, z: 14 },   // First ghost spawn (was 9, 7)
            { x: 16, z: 18 },   // Second ghost spawn (was 8, 9)
            { x: 18, z: 18 },   // Third ghost spawn (was 9, 9)
            { x: 20, z: 18 }    // Fourth ghost spawn (was 10, 9)
        ];

        // Advance to next stage
        function nextStage() {
            // Pause the game
            gameRunning = false;

            // Show stage cleared message
            const clearedStage = currentStage;
            const stageClearedDiv = document.getElementById('stageCleared');
            const stageClearedText = document.getElementById('stageClearedText');
            const extraLifeText = document.getElementById('extraLifeText');

            stageClearedText.textContent = `Stage ${clearedStage} Cleared!`;
            stageClearedDiv.style.display = 'block';

            // Check for 1-up at stages 3, 6, 9
            const isExtraLifeStage = (clearedStage === 3 || clearedStage === 6 || clearedStage === 9);
            if (isExtraLifeStage) {
                lives++;
                extraLifeText.style.display = 'block';
                updateUI();
            } else {
                extraLifeText.style.display = 'none';
            }

            // Play stage clear sound
            playStageComplete();

            // After 2 seconds, proceed to next stage or show win screen
            setTimeout(() => {
                stageClearedDiv.style.display = 'none';
                extraLifeText.style.display = 'none';

                if (currentStage >= MAX_STAGE) {
                    // Beat all stages - you win!
                    document.getElementById('gameWin').style.display = 'block';
                    return;
                }

                currentStage++;

                // Change wall color for new stage
                const newColor = stageColors[currentStage - 1];
                wallMaterial.color.setHex(newColor);

                // Reset dots
                dots.forEach(dot => scene.remove(dot));
                dots.length = 0;
                collectedDots = 0;
                totalDots = 0;
                createDots();

                // Reset ghost positions to their original spawn points
                ghosts.forEach((ghost, index) => {
                    const spawnPos = ghostSpawnPositions[index % ghostSpawnPositions.length];
                    ghost.userData.gridX = spawnPos.x;
                    ghost.userData.gridZ = spawnPos.z;
                    ghost.userData.dir = { x: 0, z: -1 };
                    ghost.position.set(
                        ghost.userData.gridX * CELL_SIZE + CELL_SIZE / 2,
                        0,
                        ghost.userData.gridZ * CELL_SIZE + CELL_SIZE / 2
                    );
                    ghost.userData.scared = false;

                    // Restore shader to normal state
                    if (ghost.userData.ghostMaterial) {
                        ghost.userData.ghostMaterial.uniforms.isScared.value = false;
                        ghost.userData.ghostMaterial.uniforms.glowColor.value.setHex(ghost.userData.originalColor);
                    }

                    // Restore core color
                    if (ghost.userData.coreMesh) {
                        ghost.userData.coreMesh.material.color.setHex(ghost.userData.originalColor);
                    }

                    // Restore particles color
                    if (ghost.userData.particleGroup) {
                        ghost.userData.particleGroup.children.forEach(p => {
                            p.material.color.setHex(ghost.userData.originalColor);
                        });
                    }

                    // Restore ghost light color
                    if (ghost.userData.ghostLight) {
                        ghost.userData.ghostLight.color.setHex(ghost.userData.originalColor);
                    }
                });

                // Reset Pac-Man to starting position (18, 30) - 2x expanded maze
                pacmanPos = { x: 18, z: 30 };
                pacmanDir = { x: 0, z: 0 };
                nextDir = { x: 0, z: 0 };
                pacmanY = GROUND_Y;
                isJumping = false;
                jumpVelocity = 0;
                pacman.position.set(
                    pacmanPos.x * CELL_SIZE + CELL_SIZE / 2,
                    GROUND_Y,
                    pacmanPos.z * CELL_SIZE + CELL_SIZE / 2
                );

                // Clear power mode if active
                if (powerTimer) {
                    clearTimeout(powerTimer);
                    powerTimer = null;
                }
                powerMode = false;

                updateUI();

                // Resume the game
                gameRunning = true;
            }, 2000);
        }

        // Play stage complete sound
        function playStageComplete() {
            if (!audioCtx || audioCtx.state === 'suspended') return;
            const ctx = audioCtx;
            const now = ctx.currentTime;

            // Victory fanfare
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.15);
                gain.gain.setValueAtTime(0.1, now + i * 0.15);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.3);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now + i * 0.15);
                osc.stop(now + i * 0.15 + 0.3);
            });
        }

        // Win game (called when all dots collected)
        function winGame() {
            nextStage();
        }

        // Restart game
        function restartGame() {
            location.reload();
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = `Score: ${score}`;
            let hearts = '';
            for (let i = 0; i < lives; i++) hearts += '‚ù§Ô∏è';
            document.getElementById('lives').textContent = `Lives: ${hearts}`;
            // Show stage
            let stageDisplay = document.getElementById('stageDisplay');
            if (!stageDisplay) {
                stageDisplay = document.createElement('div');
                stageDisplay.id = 'stageDisplay';
                stageDisplay.style.color = '#00ffff';
                stageDisplay.style.marginTop = '10px';
                document.getElementById('ui').appendChild(stageDisplay);
            }
            stageDisplay.textContent = `Stage: ${currentStage}/${MAX_STAGE}`;
        }

        // Keyboard input
        const keys = {};

        // Get camera-relative directions (Assassin's Creed style)
        // Movement is based on camera orientation, not character facing
        function getCameraRelativeDirections() {
            // Get camera's forward direction
            const cameraForward = new THREE.Vector3();
            camera.getWorldDirection(cameraForward);

            // Project onto XZ plane (ignore Y component)
            cameraForward.y = 0;
            cameraForward.normalize();

            // Snap to nearest cardinal direction for grid-based movement
            let forward, backward, left, right;

            // Determine which axis the camera is mostly facing
            if (Math.abs(cameraForward.z) >= Math.abs(cameraForward.x)) {
                // Camera mostly facing along Z axis
                if (cameraForward.z < 0) {
                    forward = { x: 0, z: -1 };
                    backward = { x: 0, z: 1 };
                    left = { x: -1, z: 0 };
                    right = { x: 1, z: 0 };
                } else {
                    forward = { x: 0, z: 1 };
                    backward = { x: 0, z: -1 };
                    left = { x: 1, z: 0 };
                    right = { x: -1, z: 0 };
                }
            } else {
                // Camera mostly facing along X axis
                if (cameraForward.x < 0) {
                    forward = { x: -1, z: 0 };
                    backward = { x: 1, z: 0 };
                    left = { x: 0, z: 1 };
                    right = { x: 0, z: -1 };
                } else {
                    forward = { x: 1, z: 0 };
                    backward = { x: -1, z: 0 };
                    left = { x: 0, z: -1 };
                    right = { x: 0, z: 1 };
                }
            }

            return { forward, backward, left, right };
        }

        // Get FPS look-relative directions (Resident Evil style - move where you look)
        function getFPSLookRelativeDirections() {
            // Use the FPS yaw angle to determine movement directions
            // This allows movement relative to where you're LOOKING, not where Pac-Man faces
            const lookX = Math.sin(fpsYawAngle);
            const lookZ = Math.cos(fpsYawAngle);

            // Snap to nearest cardinal direction for grid-based movement
            let forward, backward, left, right;

            if (Math.abs(lookZ) >= Math.abs(lookX)) {
                if (lookZ > 0) {
                    forward = { x: 0, z: 1 };
                    backward = { x: 0, z: -1 };
                    left = { x: -1, z: 0 };
                    right = { x: 1, z: 0 };
                } else {
                    forward = { x: 0, z: -1 };
                    backward = { x: 0, z: 1 };
                    left = { x: 1, z: 0 };
                    right = { x: -1, z: 0 };
                }
            } else {
                if (lookX > 0) {
                    forward = { x: 1, z: 0 };
                    backward = { x: -1, z: 0 };
                    left = { x: 0, z: 1 };
                    right = { x: 0, z: -1 };
                } else {
                    forward = { x: -1, z: 0 };
                    backward = { x: 1, z: 0 };
                    left = { x: 0, z: -1 };
                    right = { x: 0, z: 1 };
                }
            }

            return { forward, backward, left, right };
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            // Get directions based on camera mode
            let dirs;
            if (cameraMode === 1) {
                // Classic mode - absolute directions (original Pac-Man style)
                dirs = {
                    forward: { x: 0, z: -1 },  // Up on screen
                    backward: { x: 0, z: 1 },  // Down on screen
                    left: { x: -1, z: 0 },     // Left on screen
                    right: { x: 1, z: 0 }      // Right on screen
                };
            } else if (cameraMode === 2) {
                // Third-person mode - Assassin's Creed style (camera-relative)
                dirs = getCameraRelativeDirections();
            } else {
                // FPS mode - Resident Evil style (move relative to where you're looking)
                dirs = getFPSLookRelativeDirections();
            }

            if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w') {
                nextDir = dirs.forward;
            } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                nextDir = dirs.backward;
            } else if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                nextDir = dirs.left;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                nextDir = dirs.right;
            }

            // Jump with spacebar
            if (e.code === 'Space' && !isJumping && gameRunning) {
                isJumping = true;
                jumpVelocity = JUMP_FORCE;
                playJumpSound();
            }

            // Camera mode switching with 1, 2, 3 keys
            if (e.key === '1') setCameraMode(1);
            if (e.key === '2') setCameraMode(2);
            if (e.key === '3') setCameraMode(3);

            // Cheat: Press Y to skip to next stage
            if (e.key.toLowerCase() === 'y' && gameRunning) {
                nextStage();
            }

            // Keyboard camera controls (Q/E for horizontal, R/F for vertical)
            if (cameraMode === 2) {
                // Third-person mode - orbit camera (inverted for natural feel)
                if (e.key.toLowerCase() === 'q') {
                    cameraOrbitAngle += CAMERA_ROTATE_SPEED * 3;
                } else if (e.key.toLowerCase() === 'e') {
                    cameraOrbitAngle -= CAMERA_ROTATE_SPEED * 3;
                } else if (e.key.toLowerCase() === 'r') {
                    cameraPitchAngle = Math.max(CAMERA_PITCH_MIN, cameraPitchAngle - CAMERA_PITCH_SPEED * 3);
                } else if (e.key.toLowerCase() === 'f') {
                    cameraPitchAngle = Math.min(CAMERA_PITCH_MAX, cameraPitchAngle + CAMERA_PITCH_SPEED * 3);
                }
            } else if (cameraMode === 3) {
                // FPS mode - free look
                if (e.key.toLowerCase() === 'q') {
                    fpsYawAngle -= FPS_LOOK_SPEED * 3;
                } else if (e.key.toLowerCase() === 'e') {
                    fpsYawAngle += FPS_LOOK_SPEED * 3;
                } else if (e.key.toLowerCase() === 'r') {
                    fpsPitchAngle = Math.min(FPS_PITCH_MAX, fpsPitchAngle + FPS_LOOK_SPEED * 3);
                } else if (e.key.toLowerCase() === 'f') {
                    fpsPitchAngle = Math.max(FPS_PITCH_MIN, fpsPitchAngle - FPS_LOOK_SPEED * 3);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse look for FPS mode (Pointer Lock API)
        const MOUSE_SENSITIVITY = 0.002;
        let isPointerLocked = false;

        // Request pointer lock on click when in FPS mode
        document.addEventListener('click', () => {
            if (cameraMode === 3 && gameRunning && !isPointerLocked) {
                document.body.requestPointerLock();
            }
        });

        // Handle pointer lock state changes
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
            const instructions = document.getElementById('instructions');
            if (instructions && cameraMode === 3) {
                if (isPointerLocked) {
                    instructions.innerHTML = 'WASD: move | MOUSE: look | SPACE: jump | ESC: release mouse | 1/2/3: camera mode';
                } else {
                    instructions.innerHTML = 'WASD: move | Click to enable mouse look | SPACE: jump | 1/2/3: camera mode';
                }
            }
        });

        // Mouse movement for FPS look
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked || cameraMode !== 3) return;

            // Horizontal mouse movement = yaw (left/right look)
            fpsYawAngle += e.movementX * MOUSE_SENSITIVITY;

            // Vertical mouse movement = pitch (up/down look)
            fpsPitchAngle -= e.movementY * MOUSE_SENSITIVITY;
            fpsPitchAngle = Math.max(FPS_PITCH_MIN, Math.min(FPS_PITCH_MAX, fpsPitchAngle));
        });

        // Gamepad support for Xbox controller
        let gamepadIndex = null;
        let prevGamepadButtons = {};
        const STICK_DEADZONE = 0.3;

        // Detect gamepad connection
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            // Update instructions to show gamepad connected
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = 'üéÆ Controller connected! Left Stick: move | Right Stick: rotate camera | A: jump | LB+RB: cycle camera mode';
            }
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected:', e.gamepad.id);
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
            }
            // Restore keyboard instructions
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = 'WASD: move | Q/E: look left/right | R/F: look up/down | SPACE: jump | 1/2/3: camera mode';
            }
        });

        // Poll gamepad input (called in animate loop)
        function updateGamepad() {
            if (gamepadIndex === null) return;

            const gamepads = navigator.getGamepads();
            const gamepad = gamepads[gamepadIndex];
            if (!gamepad) return;

            // Start game with any button if not started
            if (!gameStarted) {
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    if (gamepad.buttons[i].pressed) {
                        const startScreen = document.getElementById('startScreen');
                        if (startScreen && startScreen.style.display !== 'none') {
                            startScreen.click();
                        }
                        break;
                    }
                }
                return;
            }

            // Left stick axes (0 = left/right, 1 = up/down)
            const leftStickX = gamepad.axes[0];
            const leftStickY = gamepad.axes[1];

            // D-pad buttons (Xbox: 12=up, 13=down, 14=left, 15=right)
            const dpadUp = gamepad.buttons[12]?.pressed;
            const dpadDown = gamepad.buttons[13]?.pressed;
            const dpadLeft = gamepad.buttons[14]?.pressed;
            const dpadRight = gamepad.buttons[15]?.pressed;

            // Determine direction from stick or d-pad
            let inputX = 0;
            let inputY = 0;

            // Prefer D-pad if pressed, otherwise use stick
            if (dpadUp) inputY = -1;
            else if (dpadDown) inputY = 1;
            else if (Math.abs(leftStickY) > STICK_DEADZONE) inputY = leftStickY > 0 ? 1 : -1;

            if (dpadLeft) inputX = -1;
            else if (dpadRight) inputX = 1;
            else if (Math.abs(leftStickX) > STICK_DEADZONE) inputX = leftStickX > 0 ? 1 : -1;

            // Set direction based on camera mode
            if (inputX !== 0 || inputY !== 0) {
                // Get directions based on camera mode
                let dirs;
                if (cameraMode === 1) {
                    // Classic mode - absolute directions
                    dirs = {
                        forward: { x: 0, z: -1 },
                        backward: { x: 0, z: 1 },
                        left: { x: -1, z: 0 },
                        right: { x: 1, z: 0 }
                    };
                } else if (cameraMode === 2) {
                    // Third-person mode - Assassin's Creed style (camera-relative)
                    dirs = getCameraRelativeDirections();
                } else {
                    // FPS mode - Resident Evil style (move relative to where you're looking)
                    dirs = getFPSLookRelativeDirections();
                }

                // Apply direction based on stick/dpad input
                if (Math.abs(inputY) >= Math.abs(inputX)) {
                    nextDir = inputY < 0 ? dirs.forward : dirs.backward;
                } else {
                    nextDir = inputX < 0 ? dirs.left : dirs.right;
                }
            }

            // Right stick for camera control
            const rightStickX = gamepad.axes[2] || 0;
            const rightStickY = gamepad.axes[3] || 0;

            if (cameraMode === 2) {
                // 3rd person mode - orbit camera (inverted for natural feel)
                if (Math.abs(rightStickX) > STICK_DEADZONE) {
                    cameraOrbitAngle -= rightStickX * CAMERA_ROTATE_SPEED;
                }
                if (Math.abs(rightStickY) > STICK_DEADZONE) {
                    cameraPitchAngle += rightStickY * CAMERA_PITCH_SPEED;
                    cameraPitchAngle = Math.max(CAMERA_PITCH_MIN, Math.min(CAMERA_PITCH_MAX, cameraPitchAngle));
                }
            } else if (cameraMode === 3) {
                // FPS mode - right stick for looking around
                if (Math.abs(rightStickX) > STICK_DEADZONE) {
                    fpsYawAngle += rightStickX * FPS_LOOK_SPEED * 2; // 2x for responsive feel
                }
                if (Math.abs(rightStickY) > STICK_DEADZONE) {
                    fpsPitchAngle -= rightStickY * FPS_LOOK_SPEED * 2; // Inverted for natural feel
                    fpsPitchAngle = Math.max(FPS_PITCH_MIN, Math.min(FPS_PITCH_MAX, fpsPitchAngle));
                }
            }

            // A button (index 0) for jump
            const aButton = gamepad.buttons[0]?.pressed;
            if (aButton && !prevGamepadButtons.a && !isJumping && gameRunning) {
                isJumping = true;
                jumpVelocity = JUMP_FORCE;
                playJumpSound();
            }
            prevGamepadButtons.a = aButton;

            // Y button (index 3) for cheat - skip to next stage
            const yButton = gamepad.buttons[3]?.pressed;
            if (yButton && !prevGamepadButtons.y && gameRunning) {
                nextStage();
            }
            prevGamepadButtons.y = yButton;

            // LB + RB (buttons 4 and 5) together - cycle camera mode
            const lbButton = gamepad.buttons[4]?.pressed;
            const rbButton = gamepad.buttons[5]?.pressed;
            const bothBumpersPressed = lbButton && rbButton;

            if (bothBumpersPressed && !prevGamepadButtons.bumpers) {
                const newMode = cameraMode === 3 ? 1 : cameraMode + 1;
                setCameraMode(newMode);
            }
            prevGamepadButtons.bumpers = bothBumpersPressed;
        }

        // Initialize game
        function init() {
            createFloor();
            createStarfield();
            createWalls();
            createDots();
            createPacman();
            createGhosts();
            updateUI();
            animate();

            // Setup start screen listeners
            const startScreen = document.getElementById('startScreen');
            const startGame = (e) => {
                if (gameStarted) return;

                // Prevent double-firing on touch devices
                if (e) {
                    e.preventDefault();
                }

                gameStarted = true;
                startScreen.style.display = 'none';

                // CRITICAL: Unlock audio SYNCHRONOUSLY within the user gesture
                // iOS requires this to happen immediately, not after await/Promise
                initAndUnlockAudio();

                // Small delay to let audio context fully initialize, then play intro
                setTimeout(() => {
                    playPacmanIntro();
                }, 100);

                // Start game after intro music finishes (~4.5 seconds)
                setTimeout(() => {
                    gameRunning = true;
                }, 4600);
            };

            // Use touchstart for iOS - it's more reliable than touchend for audio unlock
            startScreen.addEventListener('touchstart', startGame, { passive: false });
            startScreen.addEventListener('click', startGame);
            document.addEventListener('keydown', (e) => {
                if (!gameStarted) {
                    startGame(e);
                }
            }, { once: false });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            updateGamepad();
            updatePacman();
            updateGhosts();

            // Camera positioning based on current mode
            if (pacman) {
                const dirAngle = Math.atan2(pacmanDir.x, pacmanDir.z);
                const config = cameraModes[cameraMode];

                if (cameraMode === 1) {
                    // Classic mode - top-down view of entire maze
                    const targetX = MAZE_WIDTH * CELL_SIZE / 2;
                    const targetY = config.offsetY;
                    const targetZ = MAZE_HEIGHT * CELL_SIZE / 2 + config.offsetZ;

                    cameraTargetPos.set(targetX, targetY, targetZ);
                    camera.position.lerp(cameraTargetPos, 0.05);

                    cameraTargetLook.set(MAZE_WIDTH * CELL_SIZE / 2, config.lookY, MAZE_HEIGHT * CELL_SIZE / 2);
                    camera.lookAt(cameraTargetLook);

                } else if (cameraMode === 2) {
                    // Third-person mode - orbit camera around Pac-Man with pitch control
                    // Calculate camera position using orbit angle and pitch
                    const horizontalDist = config.offsetZ * Math.cos(cameraPitchAngle);
                    const verticalOffset = config.offsetY + config.offsetZ * Math.sin(cameraPitchAngle);

                    const targetX = pacman.position.x - Math.sin(cameraOrbitAngle) * horizontalDist;
                    const targetY = verticalOffset + (pacmanY - GROUND_Y);
                    const targetZ = pacman.position.z - Math.cos(cameraOrbitAngle) * horizontalDist;

                    cameraTargetPos.set(targetX, targetY, targetZ);
                    camera.position.lerp(cameraTargetPos, 0.05);

                    // Always look at Pac-Man
                    const lookX = pacman.position.x;
                    const lookY = 1.0 + (pacmanY - GROUND_Y);
                    const lookZ = pacman.position.z;

                    cameraTargetLook.lerp(new THREE.Vector3(lookX, lookY, lookZ), 0.05);
                    camera.lookAt(cameraTargetLook);

                } else if (cameraMode === 3) {
                    // FPS mode - Resident Evil style free look at Pac-Man's eye level
                    const targetX = pacman.position.x;
                    const targetY = config.eyeHeight + (pacmanY - GROUND_Y);
                    const targetZ = pacman.position.z;

                    cameraTargetPos.set(targetX, targetY, targetZ);
                    camera.position.lerp(cameraTargetPos, 0.15);

                    // Look in the direction controlled by right stick (free look)
                    const lookDistance = config.lookDistance;
                    const lookX = pacman.position.x + Math.sin(fpsYawAngle) * lookDistance * Math.cos(fpsPitchAngle);
                    const lookY = config.eyeHeight + (pacmanY - GROUND_Y) + Math.sin(fpsPitchAngle) * lookDistance;
                    const lookZ = pacman.position.z + Math.cos(fpsYawAngle) * lookDistance * Math.cos(fpsPitchAngle);

                    cameraTargetLook.lerp(new THREE.Vector3(lookX, lookY, lookZ), 0.08);
                    camera.lookAt(cameraTargetLook);
                }
            }

            // Floating animation for dots
            dots.forEach((dot, index) => {
                dot.position.y = 0.5 + Math.sin(Date.now() * 0.003 + index) * 0.1;
                dot.rotation.y += 0.02;
            });

            // Ghost ethereal animation
            const time = Date.now() * 0.001;
            ghosts.forEach((ghost, index) => {
                // Floating motion
                ghost.position.y = Math.sin(time * 2 + ghost.userData.phaseOffset) * 0.15;

                // Update shader time uniform for wavering effect
                if (ghost.userData.ghostMaterial) {
                    ghost.userData.ghostMaterial.uniforms.time.value = time + ghost.userData.phaseOffset;
                }

                // Animate core pulse
                if (ghost.userData.coreMesh) {
                    const pulseScale = 0.9 + Math.sin(time * 3 + ghost.userData.phaseOffset) * 0.1;
                    ghost.userData.coreMesh.scale.set(pulseScale, pulseScale, pulseScale);
                    ghost.userData.coreMesh.material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
                }

                // Animate floating particles around ghost
                if (ghost.userData.particleGroup) {
                    ghost.userData.particleGroup.children.forEach((particle, pIndex) => {
                        const pTime = time * particle.userData.speed;
                        const angle = particle.userData.angle + pTime;
                        const radius = particle.userData.radius;
                        const yOff = particle.userData.yOffset;

                        particle.position.x = Math.cos(angle) * radius;
                        particle.position.z = Math.sin(angle) * radius;
                        particle.position.y = -0.2 + Math.sin(pTime * 2 + pIndex) * 0.3 - yOff;

                        // Fade in/out
                        particle.material.opacity = 0.3 + Math.sin(pTime * 3 + pIndex) * 0.3;
                        particle.scale.setScalar(0.5 + Math.sin(pTime * 2) * 0.3);
                    });
                }

                // Flicker ghost light
                if (ghost.userData.ghostLight) {
                    ghost.userData.ghostLight.intensity = 0.4 + Math.sin(time * 4 + ghost.userData.phaseOffset) * 0.2;
                }
            });

            // Flickering torch light effect
            torchLight.intensity = 0.4 + Math.sin(Date.now() * 0.01) * 0.1 + Math.random() * 0.05;
            caveLight1.intensity = 0.5 + Math.sin(Date.now() * 0.008) * 0.1;
            caveLight2.intensity = 0.5 + Math.cos(Date.now() * 0.008) * 0.1;

            // Animate corner torches
            cornerTorches.forEach((torch, index) => {
                const time = Date.now() * 0.01 + index * 100;
                const flicker = Math.sin(time) * 0.2 + Math.random() * 0.1;

                // Flicker the light intensity
                torch.userData.light.intensity = 1.5 + flicker;

                // Animate flame scale and position
                torch.userData.flame.scale.y = 1 + Math.sin(time * 1.5) * 0.2;
                torch.userData.flame.scale.x = 1 + Math.cos(time * 1.2) * 0.1;
                torch.userData.flame.position.y = 2.0 + Math.sin(time * 2) * 0.05;

                // Inner flame animation (slightly different phase)
                torch.userData.innerFlame.scale.y = 1 + Math.cos(time * 1.8) * 0.25;
                torch.userData.innerFlame.position.y = 1.95 + Math.sin(time * 2.5) * 0.03;
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        init();

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('SW registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('SW registration failed:', error);
                    });
            });
        }

        // Lock screen orientation to landscape
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

        function lockOrientation() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }
        }

        function enterFullscreenAndLock() {
            if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen()
                    .then(() => lockOrientation())
                    .catch(() => {});
            } else if (document.fullscreenElement) {
                lockOrientation();
            }
        }

        // On mobile: aggressively request fullscreen + lock on any interaction
        if (isMobile) {
            // Request on start screen click
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.addEventListener('click', enterFullscreenAndLock);
            }

            // Re-request if user exits fullscreen while playing
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement && gameRunning) {
                    // Show a tap-to-fullscreen prompt briefly
                    setTimeout(() => {
                        if (!document.fullscreenElement && gameRunning) {
                            document.body.addEventListener('click', enterFullscreenAndLock, { once: true });
                        }
                    }, 500);
                } else if (document.fullscreenElement) {
                    lockOrientation();
                }
            });

            // Also lock on orientation change attempts
            window.addEventListener('orientationchange', () => {
                if (document.fullscreenElement) {
                    lockOrientation();
                }
            });
        }

        // Desktop: just lock on fullscreen
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                lockOrientation();
            }
        });
    </script>
</body>
</html>
